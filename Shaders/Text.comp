#version 450

// #extension GL_EXT_debug_printf : enable
#extension GL_GOOGLE_include_directive : enable

// Glyph instance
struct Instance
{
    vec2 uvPos;
    vec2 uvSize;
    vec2 pos;
    uint spriteIndex;
    uint color;
    vec2 rotationOrigin;
    float rotationAngle;
    bool vertical;
};

#include "PrimitiveCompute.glsl"

layout (local_size_x = 1) in;

// Area
struct Area
{
    vec2 pos;
    vec2 size;
};

// Quad
struct Quad
{
    vec2 p1;
    vec2 p2;
    vec2 p3;
    vec2 p4;
};

vec2 toRelative(const vec2 point)
{
    return (point / context.halfWindowSize) - 1.0;
}

Quad getQuad(const Area area, const uint spriteIndex, const vec2 rotationCosSin, const vec2 rotationOrigin2)
{
    Quad quad;
    Area transformed = area;

    const mat2 rotationMatrix = mat2(rotationCosSin.x, -rotationCosSin.y, rotationCosSin.y, rotationCosSin.x);
    const vec2 rotationOrigin = transformed.pos + transformed.size / 2.0;
    quad.p1 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos));
    quad.p2 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos + vec2(transformed.size.x, 0.0)));
    quad.p3 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos + transformed.size));
    quad.p4 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos + vec2(0.0, transformed.size.y)));
    return quad;
}

void main(void)
{
    const uint instanceIndex = gl_GlobalInvocationID.x;
    const Offset offset = offsets.data[instanceIndex];
    const Instance instance = instances.data[instanceIndex];
    // Compute relative UVs
    const vec2 spriteSize = textureSize(sprites[instance.spriteIndex], 0);
    const vec2 rUVPos = instance.uvPos / spriteSize;
    const vec2 rUVSize = instance.uvSize / spriteSize;
    // Compute relative area
    const vec2 rotationCosSin = vec2(cos(instance.rotationAngle), sin(instance.rotationAngle));
    const Quad quad = getQuad(Area(instance.pos, instance.uvSize), instance.spriteIndex, rotationCosSin, instance.rotationOrigin);

    // debugPrintfEXT("> Instance %u sprite: (%u) APOS (%v2f) RPOS (%v2f) RSIZE (%v2f) UV (%v2f | %v2f) RUV (%v2f | %v2f)\n",
    //     instanceIndex, instance.spriteIndex, instance.pos, rPos, rSize, instance.uvPos, instance.uvSize, rUVPos, rUVSize);
    // debugPrintfEXT("> Instance %u sprite: (%u) APOS (%v2f) UV (%v2f | %v2f) \n",
    //     instanceIndex, instance.spriteIndex, instance.pos, instance.uvPos, instance.uvSize);

    // Set vertices
    Vertex vertex;
    vertex.halfSize = instance.uvSize / 2.0;
    vertex.center = instance.pos + vertex.halfSize;
    vertex.radius = vec4(0.0);
    vertex.spriteIndex = instance.spriteIndex;
    vertex.color = instance.color;
    vertex.edgeSoftness = 0.0;
    //   TopLeft
    vertex.pos = quad.p1;
    vertex.uv = rUVPos;
    vertices.data[offset.vertexOffset + 0] = vertex;
    //   TopRight
    vertex.pos = quad.p2;
    vertex.uv = rUVPos + vec2(rUVSize.x, 0);
    vertices.data[offset.vertexOffset + 1] = vertex;
    //   BottomRight
    vertex.pos = quad.p3;
    vertex.uv = rUVPos + rUVSize;
    vertices.data[offset.vertexOffset + 2] = vertex;
    //   BottomLeft
    vertex.pos = quad.p4;
    vertex.uv = rUVPos + vec2(0, rUVSize.y);
    vertices.data[offset.vertexOffset + 3] = vertex;

    // Set indices
    //   TopRight Triangle
    indices.data[offset.indexOffset + 0] = offset.vertexOffset + 0;
    indices.data[offset.indexOffset + 1] = offset.vertexOffset + 1;
    indices.data[offset.indexOffset + 2] = offset.vertexOffset + 2;
    //   BottomLeft Triangle
    indices.data[offset.indexOffset + 3] = offset.vertexOffset + 2;
    indices.data[offset.indexOffset + 4] = offset.vertexOffset + 3;
    indices.data[offset.indexOffset + 5] = offset.vertexOffset + 0;
}