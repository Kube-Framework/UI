#version 450

// #extension GL_EXT_debug_printf : enable
#extension GL_GOOGLE_include_directive : enable

// Glyph instance
struct Instance
{
    vec2 uvPos;
    vec2 uvSize;
    vec2 pos;
    uint spriteIndex;
    uint color;
    vec2 rotationOrigin;
    float rotationAngle;
    float vertical;
};

#include "PrimitiveCompute.glsl"

layout (local_size_x = 1) in;

// Area
struct Area
{
    vec2 pos;
    vec2 size;
};

// Quad
struct Quad
{
    vec2 p1;
    vec2 p2;
    vec2 p3;
    vec2 p4;
};

vec2 toRelative(const vec2 point)
{
    return (point / context.halfWindowSize) - 1.0;
}

Quad getUVQuad(const Area uvArea, const vec2 spriteSheetSize, const float vertical)
{
    const Area ruvArea = Area(
        uvArea.pos / spriteSheetSize,
        uvArea.size / spriteSheetSize
    );

    const Quad tmp = Quad(
        ruvArea.pos,
        ruvArea.pos + vec2(ruvArea.size.x, 0.0),
        ruvArea.pos + ruvArea.size,
        ruvArea.pos + vec2(0.0, ruvArea.size.y)
    );

    return Quad(
        vertical * tmp.p4 - (vertical - 1.0) * tmp.p1,
        vertical * tmp.p1 - (vertical - 1.0) * tmp.p2,
        vertical * tmp.p2 - (vertical - 1.0) * tmp.p3,
        vertical * tmp.p3 - (vertical - 1.0) * tmp.p4
    );
}

Quad getQuad(const Area area, const vec2 rotationCosSin, const vec2 rotationOrigin, const float vertical)
{
    const mat2 rotationMatrix = mat2(rotationCosSin.x, -rotationCosSin.y, rotationCosSin.y, rotationCosSin.x);

    // const Quad tmp =
    return Quad(
        toRelative(applyRotation(rotationMatrix, rotationOrigin, area.pos)),
        toRelative(applyRotation(rotationMatrix, rotationOrigin, area.pos + vec2(area.size.x, 0.0))),
        toRelative(applyRotation(rotationMatrix, rotationOrigin, area.pos + area.size)),
        toRelative(applyRotation(rotationMatrix, rotationOrigin, area.pos + vec2(0.0, area.size.y)))
    );

    // return Quad(
    //     vertical * tmp.p4 - (vertical - 1.0) * tmp.p1,
    //     vertical * tmp.p1 - (vertical - 1.0) * tmp.p2,
    //     vertical * tmp.p2 - (vertical - 1.0) * tmp.p3,
    //     vertical * tmp.p3 - (vertical - 1.0) * tmp.p4
    // );

}

void main(void)
{
    const uint instanceIndex = gl_GlobalInvocationID.x;
    const Offset offset = offsets.data[instanceIndex];
    const Instance instance = instances.data[instanceIndex];
    // Compute relative UVs
    const vec2 spriteSheetSize = textureSize(sprites[instance.spriteIndex], 0);
    const Quad uvQuad = getUVQuad(Area(instance.uvPos, instance.uvSize), spriteSheetSize, instance.vertical);
    // Compute relative area
    const vec2 size = instance.vertical * instance.uvSize.yx - (instance.vertical - 1.0) * instance.uvSize;
    const vec2 rotationCosSin = vec2(cos(instance.rotationAngle), sin(instance.rotationAngle));
    const Quad quad = getQuad(Area(instance.pos, size), rotationCosSin, instance.rotationOrigin, instance.vertical);

    // debugPrintfEXT("> Instance %u sprite: (%u) APOS (%v2f) RPOS (%v2f) RSIZE (%v2f) UV (%v2f | %v2f) RUV (%v2f | %v2f)\n",
    //     instanceIndex, instance.spriteIndex, instance.pos, rPos, rSize, instance.uvPos, instance.uvSize, rUVPos, rUVSize);
    // debugPrintfEXT("> Instance %u sprite: (%u) APOS (%v2f) UV (%v2f | %v2f) \n",
    //     instanceIndex, instance.spriteIndex, instance.pos, instance.uvPos, instance.uvSize);

    // Set vertices
    Vertex vertex;
    vertex.halfSize = size / 2.0;
    vertex.center = instance.pos + vertex.halfSize;
    vertex.radius = vec4(0.0);
    vertex.spriteIndex = instance.spriteIndex; //NullSpriteIndex;
    vertex.color = instance.color;
    vertex.edgeSoftness = 0.0;
    //   TopLeft
    vertex.pos = quad.p1;
    vertex.uv = uvQuad.p1;
    vertices.data[offset.vertexOffset + 0] = vertex;
    //   TopRight
    vertex.pos = quad.p2;
    vertex.uv = uvQuad.p2;
    vertices.data[offset.vertexOffset + 1] = vertex;
    //   BottomRight
    vertex.pos = quad.p3;
    vertex.uv = uvQuad.p3;
    vertices.data[offset.vertexOffset + 2] = vertex;
    //   BottomLeft
    vertex.pos = quad.p4;
    vertex.uv = uvQuad.p4;
    vertices.data[offset.vertexOffset + 3] = vertex;

    // Set indices
    //   TopRight Triangle
    indices.data[offset.indexOffset + 0] = offset.vertexOffset + 0;
    indices.data[offset.indexOffset + 1] = offset.vertexOffset + 1;
    indices.data[offset.indexOffset + 2] = offset.vertexOffset + 2;
    //   BottomLeft Triangle
    indices.data[offset.indexOffset + 3] = offset.vertexOffset + 2;
    indices.data[offset.indexOffset + 4] = offset.vertexOffset + 3;
    indices.data[offset.indexOffset + 5] = offset.vertexOffset + 0;
}