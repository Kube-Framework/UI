#version 450

// #extension GL_EXT_debug_printf : enable
#extension GL_GOOGLE_include_directive : enable

// Area
struct Area
{
    vec2 pos;
    vec2 size;
};

// Rectangle instance
struct Instance
{
    Area area;
    vec4 radius;
    uint spriteIndex;
    uint fillMode;
    uint color;
    uint borderColor;
    float borderWidth;
    float edgeSoftness;
    float rotationAngle;
};

#include "FilledQuadUtils.glsl"
#include "PrimitiveCompute.glsl"

// Quad
struct Quad
{
    vec2 p1;
    vec2 p2;
    vec2 p3;
    vec2 p4;
};

layout (local_size_x = 1) in;

vec2[4] getUVs(const vec2 size, const uint spriteIndex, const uint fillMode)
{
    vec2[4] uvs = vec2[4](
        vec2(0.0, 0.0),
        vec2(1.0, 0.0),
        vec2(1.0, 1.0),
        vec2(0.0, 1.0)
    );
    if (spriteIndex != NullSpriteIndex && fillMode == FillModeCrop) {
        // Query sprite size
        const vec2 spriteSize = textureSize(sprites[spriteIndex], 0);
        // Compute resize factor
        const bool isSpriteGreater = (spriteSize.x / spriteSize.y) >= (size.x / size.y);
        const float resizeFactor = float(!isSpriteGreater) * (size.x / spriteSize.x) + float(isSpriteGreater) * (size.y / spriteSize.y);
        // Compute scaling
        const vec2 newSize = vec2(spriteSize.x * resizeFactor, spriteSize.y * resizeFactor);
        const vec2 offset = vec2(
            (1.0 - (size.x / newSize.x)) / 2.0,
            (1.0 - (size.y / newSize.y)) / 2.0
        );
        uvs[0] += offset;
        uvs[1] += vec2(-offset.x, offset.y);
        uvs[2] -= offset;
        uvs[3] += vec2(offset.x, -offset.y);
    }
    return uvs;
}

Quad getQuad(const Area area, const uint spriteIndex, const uint fillMode, const vec2 rotationCosSin)
{
    Quad quad;
    Area transformed = area;

    if (spriteIndex != NullSpriteIndex && fillMode == FillModeFit) {
        // Query sprite size
        const vec2 spriteSize = textureSize(sprites[spriteIndex], 0);
        // Compute resize factor
        const bool isSpriteGreater = (spriteSize.x / spriteSize.y) >= (area.size.x / area.size.y);
        const float resizeFactor = float(isSpriteGreater) * (area.size.x / spriteSize.x) + float(!isSpriteGreater) * (area.size.y / spriteSize.y);
        // Compute scaling
        transformed.size = vec2(spriteSize.x * resizeFactor, spriteSize.y * resizeFactor);
        transformed.pos = vec2(
            area.pos.x + (area.size.x - transformed.size.x) / 2.0,
            area.pos.y + (area.size.y - transformed.size.y) / 2.0
        );
    }

    const mat2 rotationMatrix = mat2(rotationCosSin.x, -rotationCosSin.y, rotationCosSin.y, rotationCosSin.x);
    const vec2 rotationOrigin = transformed.pos + transformed.size / 2.0;
    quad.p1 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos));
    quad.p2 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos + vec2(transformed.size.x, 0.0)));
    quad.p3 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos + transformed.size));
    quad.p4 = toRelative(applyRotation(rotationMatrix, rotationOrigin, transformed.pos + vec2(0.0, transformed.size.y)));
    return quad;
}

void main(void)
{
    const uint instanceIndex = gl_GlobalInvocationID.x;
    const Offset offset = offsets.data[instanceIndex];
    const Instance instance = instances.data[instanceIndex];
    const vec2 uvs[4] = getUVs(instance.area.size, instance.spriteIndex, instance.fillMode);
    const vec2 rotationCosSin = vec2(cos(instance.rotationAngle), sin(instance.rotationAngle));
    const Quad quad = getQuad(instance.area, instance.spriteIndex, instance.fillMode, rotationCosSin);

    // debugPrintfEXT("> Instance %u sprite: (%u) pos: (%v2f) size: (%v2f) realPos: (%v2f) realSize: (%v2f) vertexOffset: verticesOffset %u indexOffset: %u color: (%u ==> %v4f)\n",
    //     instanceIndex, instance.spriteIndex, instance.area.pos, instance.area.size, pos, size, offset.vertexOffset, offset.indexOffset,
    //     instance.color, unpackUnorm4x8(instance.color));

    // Set vertices
    Vertex vertex;
    vertex.halfSize = (instance.area.size - 1.0) / 2.0;
    vertex.center = instance.area.pos + instance.area.size / 2.0;
    vertex.radius = instance.radius;
    vertex.spriteIndex = instance.spriteIndex;
    vertex.color = instance.color;
    vertex.borderColor = instance.borderColor;
    vertex.borderWidth = instance.borderWidth;
    vertex.edgeSoftness = instance.edgeSoftness;
    vertex.rotationCosSin = rotationCosSin;
    //   TopLeft
    vertex.pos = quad.p1;
    vertex.uv = uvs[0];
    vertices.data[offset.vertexOffset + 0] = vertex;
    //   TopRight
    vertex.pos = quad.p2;
    vertex.uv = uvs[1];
    vertices.data[offset.vertexOffset + 1] = vertex;
    //   BottomRight
    vertex.pos = quad.p3;
    vertex.uv = uvs[2];
    vertices.data[offset.vertexOffset + 2] = vertex;
    //   BottomLeft
    vertex.pos = quad.p4;
    vertex.uv = uvs[3];
    vertices.data[offset.vertexOffset + 3] = vertex;

    // Set indices
    //   TopRight Triangle
    indices.data[offset.indexOffset + 0] = offset.vertexOffset + 0;
    indices.data[offset.indexOffset + 1] = offset.vertexOffset + 1;
    indices.data[offset.indexOffset + 2] = offset.vertexOffset + 2;
    //   BottomLeft Triangle
    indices.data[offset.indexOffset + 3] = offset.vertexOffset + 2;
    indices.data[offset.indexOffset + 4] = offset.vertexOffset + 3;
    indices.data[offset.indexOffset + 5] = offset.vertexOffset + 0;
}